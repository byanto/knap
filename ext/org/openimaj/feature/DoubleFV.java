/*
AUTOMATICALLY GENERATED BY jTemp FROM
/Users/jon/Work/openimaj/tags/openimaj-1.3.1/core/core-feature/src/main/jtemp/org/openimaj/feature/#T#FV.jtemp
*/
/**
* Copyright (c) 2011, The University of Southampton and the individual contributors.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*   *  Redistributions of source code must retain the above copyright notice,
*  this list of conditions and the following disclaimer.
*
*   *  Redistributions in binary form must reproduce the above copyright notice,
*  this list of conditions and the following disclaimer in the documentation
*  and/or other materials provided with the distribution.
*
*   *  Neither the name of the University of Southampton nor the names of its
*  contributors may be used to endorse or promote products derived from this
*  software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package org.knime.base.node.audio.ext.org.openimaj.feature;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

import org.knime.base.node.audio.ext.org.openimaj.util.concatenate.Concatenatable;

/**
 * Basic double single-dimensional feature vector implementation
 *
 * @author Jonathon Hare
 */
public class DoubleFV extends ArrayFeatureVector<double[]> implements Concatenatable<DoubleFV, DoubleFV>{
    private static final long serialVersionUID = 1L;

    /**
     * Construct an empty feature vector
     */
    public DoubleFV() {
    }

    /**
     * Construct empty FV with given number of bins
     *
     * @param nbins the number of bins in each dimension
     */
    public DoubleFV(final int nbins) {
        m_values = new double[nbins];
    }

    /**
     * Construct from flattened values array and dimensions
     *
     * @param values the flat array of values
     */
    public DoubleFV(final double[] values) {
        this.m_values = values;
    }

    /**
     * Get the element at the given flat index
     *
     * @param x the flattened element index
     * @return the value corresponding to x
     */
    public double get(final int x) {
        return m_values[x];
    }

    /**
     * Set the element at the given flat index
     *
     * @param value the value to set
     * @param x the flattened element index
     */
    void set(final double value, final int x) {
        m_values[x] = value;
    }

    /**
     * Element-wise normalisation to 0..1 using separated expected minimum and maximum values for each element of the
     * underlying feature vector.
     *
     * @param min an array containing the minimum expected values
     * @param max an array containing the maximum expected values
     * @return feature vector with each value normalised to 0..1
     */
    @Override
    public DoubleFV normaliseFV(final double[] min, final double[] max) {
        double[] dvals = asDoubleVector();

        for (int i = 0; i < dvals.length; i++) {
            dvals[i] -= min[i];
            dvals[i] /= (max[i] - min[i]);

            if (dvals[i] < 0) {
                dvals[i] = 0;
            }
            if (dvals[i] > 1) {
                dvals[i] = 1;
            }
        }

        return new DoubleFV(dvals);
    }

    /**
     * Min-Max normalisation of the FV. Each element of the underlying feature vector is normalised to 0..1 based on the
     * provided minimum and maximum expected values.
     *
     * @param min the minimum expected value
     * @param max the maximum expected value
     * @return feature vector with each value normalised to 0..1
     */
    @Override
    public DoubleFV normaliseFV(final double min, final double max) {
        double[] dvals = asDoubleVector();

        for (int i = 0; i < dvals.length; i++) {
            dvals[i] -= min;
            dvals[i] /= (max - min);

            if (dvals[i] < 0) {
                dvals[i] = 0;
            }
            if (dvals[i] > 1) {
                dvals[i] = 1;
            }
        }

        return new DoubleFV(dvals);
    }

    /**
     * Normalise the FV to unit area.
     *
     * @return feature vector with all elements summing to 1.
     */
    @Override
    public DoubleFV normaliseFV() {
        double[] dvals = asDoubleVector();
        double sum = 0;

        for (int i = 0; i < dvals.length; i++) {
            sum += dvals[i];
        }

        for (int i = 0; i < dvals.length; i++) {
            dvals[i] /= sum;
        }

        return new DoubleFV(dvals);
    }

    /**
     * Lp Norm of the FV.
     *
     * @param p the norm to compute
     *
     * @return feature vector normalised using the Lp norm
     */
    @Override
    public DoubleFV normaliseFV(final double p) {
        double[] dvals = asDoubleVector();
        double pnorm = 0;

        for (int i = 0; i < dvals.length; i++) {
            pnorm += Math.pow(dvals[i], p);
        }

        pnorm = Math.pow(pnorm, 1.0 / p);

        for (int i = 0; i < dvals.length; i++) {
            dvals[i] /= pnorm;
        }

        return new DoubleFV(dvals);
    }

    @Override
    public DoubleFV clone() {
        try {
            DoubleFV model = (DoubleFV)super.clone();
            model.m_values = m_values.clone();
            return model;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
    }

    @Override
    public String toString() {
        String ret = this.getClass().getName() + Arrays.toString(m_values);

        return ret;
    }

    /**
     * Convert the FV to a DoubleFV representation
     *
     * @return the DoubleFV representation
     */
    @Override
    public DoubleFV asDoubleFV() {
        return new DoubleFV(asDoubleVector());
    }

    /**
     * Convert the FV to a 1-dimensional double array representation
     *
     * @return the double[] representation
     */
    @Override
    public double[] asDoubleVector() {
        double[] d = new double[m_values.length];

        for (int i = 0; i < m_values.length; i++) {
            d[i] = m_values[i];
        }

        return d;
    }

    /**
     * Compare this FV to another with the given method.
     *
     * @param h the feature to compare against.
     * @param method the method to compare with.
     * @return a score determined by the comparison method.
     */
    public double compare(final DoubleFV h, final DoubleFVComparison method) {
        return method.compare(this, h);
    }

    /* (non-Javadoc)
     * @see org.openimaj.feature.FeatureVector#length()
     */
    @Override
    public int length() {
        return m_values.length;
    }

    @Override
    public void writeBinary(final DataOutput out) throws IOException {
        out.writeInt(m_values.length);
        for (int i = 0; i < m_values.length; i++) {
            out.writeDouble(m_values[i]);
        }
    }

    @Override
    public void writeASCII(final PrintWriter out) throws IOException {
        out.println(m_values.length);
        for (int i = 0; i < m_values.length; i++) {
            out.print(m_values[i] + " ");
        }
        out.println();
    }

    @Override
    public void readBinary(final DataInput in) throws IOException {
        int nbins = in.readInt();
        m_values = new double[nbins];
        for (int i = 0; i < nbins; i++) {
            m_values[i] = in.readDouble();
        }
    }

    @Override
    public void readASCII(final Scanner in) throws IOException {
        int nbins = Integer.parseInt(in.nextLine());
        m_values = new double[nbins];
        String[] line = in.nextLine().trim().split(" ");
        for (int i = 0; i < nbins; i++) {
            m_values[i] = Double.parseDouble(line[i]);
        }
    }

    @Override
    public byte[] binaryHeader() {
        return (this.getClass().getName().substring(0, 2) + "FV").getBytes();
    }

    @Override
    public String asciiHeader() {
        return this.getClass().getName() + " ";
    }

    @Override
    public DoubleFV concatenate(final DoubleFV... ins) {
        int l = m_values.length;

        for (int i = 0; i < ins.length; i++) {
            l += ins[i].m_values.length;
        }

        double[] data = new double[l];

        System.arraycopy(m_values, 0, data, 0, m_values.length);
        int offset = m_values.length;
        for (int i = 0; i < ins.length; i++) {
            System.arraycopy(ins[i].m_values, 0, data, offset, ins[i].m_values.length);
            offset += ins[i].m_values.length;
        }

        return new DoubleFV(data);
    }

    @Override
    public DoubleFV concatenate(final List<DoubleFV> ins) {
        int l = m_values.length;

        for (int i = 0; i < ins.size(); i++) {
            l += ins.get(i).m_values.length;
        }

        double[] data = new double[l];

        System.arraycopy(m_values, 0, data, 0, m_values.length);
        int offset = m_values.length;
        for (int i = 0; i < ins.size(); i++) {
            System.arraycopy(ins.get(i).m_values, 0, data, offset, ins.get(i).m_values.length);
            offset += ins.get(i).m_values.length;
        }

        return new DoubleFV(data);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(m_values);
    }

    @Override
    public boolean equals(final Object obj) {
        return Arrays.equals(m_values, ((DoubleFV)obj).m_values);
    }

    @Override
    public DoubleFV subvector(final int beginIndex) {
        return new DoubleFV(Arrays.copyOfRange(this.m_values, beginIndex, m_values.length));
    }

    @Override
    public DoubleFV subvector(final int beginIndex, final int endIndex) {
        return new DoubleFV(Arrays.copyOfRange(this.m_values, beginIndex, endIndex));
    }
}
